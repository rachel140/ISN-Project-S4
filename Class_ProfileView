import customtkinter as ctk
from PIL import Image, ImageTk, ImageDraw, ImageFont


class ProfileView():
    def __init__(self):
        """
        Initialize the profile view for a country.
        
        Parameters:
        - parent: the parent window
        - country_per_long: dictionnary {longitude: average_elevation}
        - sea_level: float (sea will be displayed in blue)
        """
        
        super().__init__()

        self.image = None
        self.photo = None
        self.dico_per_long = {}
        self.max_elevation = 1
        self.sea_level = 0
        self.axis_font = ImageFont.truetype("arial.ttf", size=18)

        self.sky_image = None  # Background image


    def draw_profile(self, frame, width, height, dico_per_long, sea_level):
        self.canvas = ctk.CTkCanvas(frame, width=width, height=height, bg="white")
        self.canvas.pack(fill=ctk.BOTH, expand=True)
        
        self.dico_per_long = dict(sorted(dico_per_long.items()))
        self.max_elevation = max(self.dico_per_long.values(), default=1)
        self.sea_level = sea_level
        self.load_sky_image()
        self.redraw()
        
        self.canvas.bind("<Configure>", self.on_resize)

    def load_sky_image(self):
        try:
            bg = Image.open("blue.jpg").convert("RGB")
            self.sky_image = bg
        except Exception as e:
            print("Error loading blue.jpg:", e)
            self.sky_image = None

    def redraw(self):
        if not self.dico_per_long:
            return
    
        img_width = self.canvas.winfo_width()
        img_height = self.canvas.winfo_height()
    
        top_margin = 50     # Reserve 50 pixels at the top
        bottom_margin = 100  # Reserve 100 pixels at the bottom
        usable_height = img_height - top_margin - bottom_margin
        display_max_elevation = self.max_elevation
    
        image = Image.new("RGB", (img_width, img_height), "white")
    
        # Calculate sea level position with top_margin offset
        sea_y = int(top_margin + usable_height * (1 - self.sea_level / display_max_elevation))
    
        # Draw sky
        if self.sky_image and sea_y > top_margin:
            resized_sky = self.sky_image.resize((img_width, sea_y))
            image.paste(resized_sky, (0, 0))
    
        draw = ImageDraw.Draw(image)
    
        # Draw elevation profile
        longs = list(self.dico_per_long.keys())
        elevations = list(self.dico_per_long.values())
    
        min_long = min(longs)
        max_long = max(longs)
        long_range = max_long - min_long if max_long != min_long else 1
    
        points = []
        for i, lon in enumerate(longs):
            x = int((lon - min_long) / long_range * img_width)
            elev = elevations[i]
            y = int(top_margin + usable_height * (1 - elev / display_max_elevation))
            points.append((x, y))
    
        if points:
            fill_area = points + [(points[-1][0], img_height), (points[0][0], img_height)]
            draw.polygon(fill_area, fill=(0, 102, 51))
    
        draw.line([(0, sea_y), (img_width, sea_y)], fill="blue", width=2)
    
        # Below-sea overlay
        overlay = Image.new("RGB", (img_width, img_height), (0, 0, 255))
        mask = Image.new("L", (img_width, img_height), 0)
        mask_draw = ImageDraw.Draw(mask)
        mask_draw.rectangle([(0, sea_y), (img_width, img_height)], fill=80)
        image = Image.composite(overlay, image, mask)
    
        draw = ImageDraw.Draw(image)
    
        # Draw white vertical strip (5% of width)
        bar_width = 100
        draw.rectangle([(0, 0), (bar_width, img_height)], fill="white")
    
        # Y-axis ticks every 200 meters
        tick_interval = 200
        max_tick_value = ((self.max_elevation // tick_interval) + 1) * tick_interval
    
        tick_value = 0
        while tick_value <= max_tick_value:
            y = int(top_margin + usable_height * (1 - tick_value / display_max_elevation))
            draw.text((12, y - 7), f"{tick_value} m", fill="black", font=self.axis_font)
            draw.line([(bar_width - 10, y), (bar_width, y)], fill="black", width=1)
            tick_value += tick_interval
    
        # Draw sea level tick and label in blue
        draw.text((bar_width+20, sea_y), f"Sea level: {float(self.sea_level)} m", fill="white", font=self.axis_font)
        #draw.text((bar_width+25, sea_y), f"{int(self.sea_level)} m", fill="white", font=self.axis_font)
    
        # Render image to canvas
        self.image = image
        self.photo = ImageTk.PhotoImage(image)
        self.canvas.image = self.photo  # Keep a reference to avoid garbage collection
        self.canvas.delete("all")
        self.canvas.create_image(0, 0, anchor="nw", image=self.photo)

    def on_resize(self, event):
        self.redraw()
