import csv
import netCDF4 as nc
from shapely.geometry import Polygon
from math import cos

class ElevationData:

    def __init__(self, file_name):

       self.netcdf_files  = file_name
       self.elevation_dict = {} # Initialize an empty dictionary: { elevation → [[lat, lon], ...] }
       self.create_elevation()

    def create_elevation(self):

        """
        Load the data from several nc files containing the elevation, longitude and altitude of all points on Earth (with a precision to the 15 arc-minute). Convert the data to create a dictionary with the key being an elevation and the value a list of tuples (latitude, longitude), in degrees, of all points being at the given elevation (in meters).

        elevation_dico = { “elevation1” : [ [lat1, long1], [lat2, long2], …],
                          evation2” : [ [lat1, long1], [lat2, long2], …],
                          ,
                          }
        Parameters:
            -------
            files_name: list of strings
            corresponding to the name of the nc files containing the data for the latitude, longitude and elevation of all points on Earth.

        Returns:
            -------
            elevation_dico: dict
            associates each elevation in meters to a list of tuples (latitude, longitude) in degrees at the given elevation.
        """

        # Read the NetCDF file
        with nc.Dataset(self.netcdf_files, mode='r') as dataset:
            # Read the latitude and longitude arrays of the NetCDF file
            lats = dataset.variables['lat'][:]
            lons = dataset.variables['lon'][:]

            # Read the elevation matrix (2D array: lat x lon)
            elevations = dataset.variables['z'][:]


            # Define the step of the array to have a 0.5° resolution
            # Convert the 15 arc-minute resolution :
            # Given that 1°= 60 arc-minute, 0.5° = 30 arc-mintues
            # So keep every 2nd point
            step = 10

            # Get indices that will give us data at 0.5° spacing
            lat_indices = list(range(0, len(lats), step))
            lon_indices = list(range(0, len(lons), step))

            # Loop through selected lat/lon lists
            for i in lat_indices:
                for j in lon_indices:
                    lat = round(float(lats[i]))
                    lon = round(float(lons[j]))
                    elev = round(float(elevations[i, j]))

                    # Initialize list for this elevation if it doesn't exist
                    if elev not in self.elevation_dict:
                        self.elevation_dict[elev] = []

                        # Add the coordinate pair [lat, lon] to the elevation_dict dictionary at index elevation (elev)
                        self.elevation_dict[elev].append([lat, lon])

    def build_dico_visible_points (self):
        """
        Go through each point of the dictionary corresponding to the country clicked and test if the elevation of the point is superior to the ocean’s elevation. If not, we don’t take the point into account,
        If so, the point will be stored in the new dictionary, containing only points that aren’t submerged.

        Parameters :
            -------
            controller: Controller

        Returns :
            -------
            new_country : dict
            Of the form: { point _2= [lat2, long2, elev2]..  : dict

        """
        new_country = {}
        if self.controller.find_country() == 'Brazil':

            dico_country = self.dico_Brazil
            for i in range(len(dico_country)):
                new_country[i] = dico_country[i]

def create_polygon(self, fichier_csv):
            df = pd.read_csv(fichier_csv, encoding='utf-8', delimiter=",")
            coords = []
            for (_, row) in df.iterrows():
                lat = row['Latitude']
                lon = row['Longitude']
                coords.append((lon, lat))
            #print(len(coords))
            self.polygon = Polygon(coords)
            return self.polygon
            
def test_if_point_in(self, where_clicked):
            lat, lon = where_clicked
            point = Point(lon, lat)
            is_inside = self.polygon.contains(point)
            return is_inside

 def build_dico_per_long (new_country, sea_level) : 
    
    """
    This functions computes the average of all the elevations above the water for each longitude of the country
    
    Parameters : 
    -------
    new_country: dict
    
    Returns : 
    -------
    country_per_long: dict
    Of the form { long : average_elevation …}
    """
    
    dico_per_long = {} 
    for i in new_country : 
        longitude = new_country[i][1]
        elevation = new_country[i][2]
        if longitude in dico_per_long and elevation > sea_level : #only take into account points that are above the water
            dico_per_long[longitude].append(elevation - sea_level)
        else : 
            dico_per_long[longitude]=[elevation]
    for longitude, elevations in dico_per_long.items() :
        average = (sum(elevations)/(len(elevations)))
        dico_per_long[longitude]= average
    return dico_per_long
    
def compute_refugees(self, year, elevation_year, elevation_2025):
        """
        Compute the number of climatic refugees due to the elevation of sea level.
        Define the limits of the continents considering the points the most at north, east, south and west of each continent.
        store these limits in lists of tuples (lat, long) in order north, east, south and west:
            limits_continent= [(lat_max_north, long_max_north),(lat_max_east, long_max_east),(lat_max_south, long_max_south),(lat_max_west, long_max_west)]

        Returns:
        -------
            nb_refugees: (int) number of climatic refugees according to the year chosen by the user and the scenario.

        """
        nb_refugees = 0   #initialize the number of climatic refugees to zero in 2025
        one_deg_lat = 111320   #conversion of one degree in latitude into a distance in meters
        one_deg_long = 111320  #conversion of one degree in longitude into a distance in meters
        
        #Define the average inhabitant density for each continent
        avg_inhabitant_density_asia = 149,7
        avg_inhabitant_density_africa = 47,2
        avg_inhabitant_density_america = 33,7
        avg_inhabitant_density_europe = 24,3
        avg_inhabitant_density_oceania = 5,2
        
        #Define the limits of each continent and create polygons with these limits
        limits_asia= [(81.287, 95.521),(65.781,169.057),(-11.009, 122.876),(39.480, 26.063)]
        polygon_asia = Polygon(limits_asia)
        limits_africa = [(37.347, 9.745), (10.445, 51.414), (-34.829, 20.003), (14.741, -17.529)]
        polygon_africa = Polygon(limits_africa)
        limits_america = [(72.002, -94.567), (-7.155, -34.793), (-53.896, -71.301),(65.641, -168.142)]
        polygon_america = Polygon(limits_america)
        limits_europe = [(71.131, 27.652), (68.314, 68.264), (36, -5.600), (38.783, -9.500)]
        polygon_europe = Polygon(limits_europe)
        limits_oceania = [(28.417, -178.333), (-24.4, -124.800), (52.617, 168.133), (-53.022, 72.578)]
        polygon_oceania = Polygon(limits_oceania)
        
        if year > 2025:  #Check if the user chose a year in the future
            for elev, list_points in self.elevation_dict.items():
                if elev > elevation_year and elev <= elevation_2025:
                    for coord in list_points: 
                        point = Point(coord)
                        surface = one_deg_lat * one_deg_long * cos(coord[0])  #compute the surface covered by each point according to its latitude
                        if polygon_asia.contains(point):
                            nb_refugees += avg_inhabitant_density_asia * surface
                            
                        elif polygon_africa.contains(point):
                            nb_refugees += avg_inhabitant_density_africa * surface
                            
                        elif polygon_america.contains(point):                            
                            nb_refugees += avg_inhabitant_density_america * surface
                            
                        elif polygon_europe.contains(point):                            
                            nb_refugees += avg_inhabitant_density_europe * surface
                            
                        elif polygon_oceania.contains(point):                            
                            nb_refugees += avg_inhabitant_density_oceania * surface
                            
        return nb_refugees

file_name = 'ETOPO_2022_v1_60s_N90W180_bed.nc'
file_france = 'fr_with_elevation.csv'
file_java = 'id.json'
file_bazil = 'geoBoundaries-BRA-ADM0_simplified.geojson'
dict_sea = ElevationData(file_name)
