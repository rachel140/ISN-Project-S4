import netCDF4 as nc
from shapely.geometry import Polygon, Point, MultiPoint
from math import cos, radians
import pandas as pd

class ElevationData:
    
    def __init__(self, file_name):
        
        
       
       self.netcdf_files  = file_name
       self.elevation_dict = {} # Initialize an empty dictionary: { elevation → [[lat, lon], ...] }
       self.create_elevation()
       #self.dict_test = {50: [[-80, 90], [65.234114, 100.368612]], 49: [[-80, 90], [65.234114, 100.368612]], 899: [[-80, 90], [65.234114, 100.368612]], -1000: [[-80, 90], [65.234114, 100.368612]]}
       #self.dict_test = dict(list(self.elevation_dict.items())[5:])
       
       self.nb_refugees = self.compute_refugees(2030,10000,0.21)
       print(self.nb_refugees)
       
            
            
    def create_elevation(self):
        
        """
        Load the data from several nc files containing the elevation, longitude and altitude of all points on Earth (with a precision to the 15 arc-minute). Convert the data to create a dictionary with the key being an elevation and the value a list of tuples (latitude, longitude), in degrees, of all points being at the given elevation (in meters).

        elevation_dico = { “elevation1” : [ [lat1, long1], [lat2, long2], …],
                          evation2” : [ [lat1, long1], [lat2, long2], …],
                          ,
                          }
        Parameters: 
            -------
            files_name: list of strings 
            corresponding to the name of the nc files containing the data for the latitude, longitude and elevation of all points on Earth.

        Returns:
            -------
            elevation_dico: dict
            associates each elevation in meters to a list of tuples (latitude, longitude) in degrees at the given elevation.
        """

        

        # Read the NetCDF file
        with nc.Dataset(self.netcdf_files, mode='r') as dataset:
            # Read the latitude and longitude arrays of the NetCDF file
            lats = dataset.variables['lat'][:]
            lons = dataset.variables['lon'][:]

            # Read the elevation matrix (2D array: lat x lon)
            elevations = dataset.variables['z'][:]

            
            # Define the step of the array to have a 0.5° resolution
            # Convert the 15 arc-minute resolution :
            # Given that 1°= 60 arc-minute, 0.5° = 30 arc-mintues
            # So keep every 2nd point
            step = 5

            # Get indices that will give us data at 0.5° spacing
            lat_indices = list(range(0, len(lats), step))
            lon_indices = list(range(0, len(lons), step))

            # Loop through selected lat/lon lists
            for i in lat_indices:
                for j in lon_indices:
                    lat = round(float(lats[i]))
                    lon = round(float(lons[j]))
                    elev = round(float(elevations[i, j]))  

                    # Initialize list for this elevation if it doesn't exist
                    if elev not in self.elevation_dict:
                        self.elevation_dict[elev] = []

                        # Add the coordinate pair [lat, lon] to the elevation_dict dictionary at index elevation (elev)
                        self.elevation_dict[elev].append([lat, lon])

            
    
    def create_polygon(self, fichier_csv):
            df = pd.read_csv(fichier_csv, encoding='utf-8', delimiter=",")
            coords = []
            for (_, row) in df.iterrows():
                lat = row['Latitude']
                lon = row['Longitude']
                coords.append((lon, lat))
            #print(len(coords))
            self.polygon = Polygon(coords)
            return self.polygon
            
    def test_if_point_in(self, where_clicked):
            lat, lon = where_clicked
            point = Point(lon, lat)
            is_inside = self.polygon.contains(point)
            return is_inside


                    
                    
                    
    def build_dico_visible_points (self):
        """ 
        Go through each point of the dictionary corresponding to the country clicked and test if the elevation of the point is superior to the ocean’s elevation. If not, we don’t take the point into account, 
        If so, the point will be stored in the new dictionary, containing only points that aren’t submerged.

        Parameters : 
            -------
            controller: Controller

        Returns : 
            -------
            new_country : dict
            Of the form: { point _2= [lat2, long2, elev2]..  : dict
    
        """
        new_country = {}
        if self.controller.find_country() == 'Brazil':
            
            dico_country = self.dico_Brazil
            for i in range(len(dico_country)):
                new_country[i] = dico_country[i]
                
            
        
        
        
    def build_dico_per_long (new_country) : 
        """
        This functions computes the average of all the latitudes for each longitude of the country

        Parameters : 
            -------
            new_country: dict

        Returns : 
            -------
            country_per_long: dict
            Of the form { long : average_lat …}
        """
        
    def compute_refugees(self, year, elevation_year, elevation_2022):
        """
        Compute the number of climatic refugees due to the elevation of sea level.
        Define the limits of the continents considering the points the most at north, east, south and west of each continent.
        store these limits in lists of tuples (lat, long) in order north, east, south and west:
            limits_continent= [(lat_max_north, long_max_north),(lat_max_east, long_max_east),(lat_max_south, long_max_south),(lat_max_west, long_max_west)]

        Returns:
        -------
            nb_refugees: (int) number of climatic refugees according to the year chosen by the user and the scenario.

        """
        nb_refugees = 32000000   #initialize the number of climatic refugees to 32 million in 2022
        one_deg_lat = 111.320   #conversion of one degree in latitude into a distance in kilometers
        one_deg_long = 111.320  #conversion of one degree in longitude into a distance in kilometers
        
        #Define the average inhabitant density for each continent in number of inhabitants per squared kilometer
        avg_inhabitant_density_asia = 149.7
        avg_inhabitant_density_africa = 47.2
        avg_inhabitant_density_america = 33.7
        avg_inhabitant_density_europe = 109
        avg_inhabitant_density_oceania = 5.2
        
        #Define the limits of each continent and create polygons with these limits
        limits_asia = [[30.0, 80.0],   [180.0, 80.0],  [180.0, -15.0], [130.0, -15.0], [90.0, -20.0],  [50.0, -20.0], [30.0, 0.0], [20.0, 10.0],[20.0, 40.0], [30.0, 80.0] ]
        polygon_asia = MultiPoint(limits_asia).convex_hull
        
        limits_africa = [[-30.0, 40.0], [60.0, 40.0], [60.0, -40.0], [20.0, -50.0], [-30.0, -40.0], [-30.0, 0.0], [-30.0, 40.0]]
        polygon_africa = MultiPoint(limits_africa).convex_hull
        
        limits_namerica = [[-170.0, 85.0], [-30.0, 85.0], [-30.0, 10.0], [-60.0, 5.0], [-100.0, 5.0], [-170.0, 10.0], [-170.0, 85.0]]
        polygon_namerica = MultiPoint(limits_namerica).convex_hull
        
        limits_samerica = [-90.0, 15.0], [-30.0, 15.0], [-30.0, -60.0], [-90.0, -60.0], [-90.0, 15.0]
        polygon_samerica = MultiPoint(limits_samerica).convex_hull
        
        limits_europe = [-30.0, 75.0], [60.0, 75.0], [60.0, 35.0], [30.0, 30.0], [0.0, 30.0], [-30.0, 40.0], [-30.0, 75.0]
        polygon_europe = MultiPoint(limits_europe).convex_hull
        
        limits_oceania = [ [110.0, 0.0], [180.0, 0.0], [180.0, -50.0], [110.0, -50.0], [110.0, 0.0] ]
        polygon_oceania = MultiPoint(limits_oceania).convex_hull
        
        if year > 2022:  #Check if the user chose a year in the future
            for elev, list_points in self.elevation_dict.items():
                
            #for elev, list_points in self.dict_test.items():
                if elev < elevation_year and elev >= elevation_2022:
                    for coord in list_points: 
                        point = Point(coord[1], coord[0])
                        
                        #surface = one_deg_lat * one_deg_long * abs(cos(radians(coord[0])))  #compute the surface covered by each point according to its latitude
                        surface = one_deg_lat * one_deg_long
                        
                        if polygon_asia.contains(point):
                            nb_refugees += avg_inhabitant_density_asia * surface
                            
                        elif polygon_africa.contains(point):
                            nb_refugees += avg_inhabitant_density_africa * surface
                            
                        elif polygon_namerica.contains(point):                            
                            nb_refugees += avg_inhabitant_density_america * surface
                            
                        elif polygon_samerica.contains(point):                            
                            nb_refugees += avg_inhabitant_density_america * surface
                            
                        elif polygon_europe.contains(point):                            
                            nb_refugees += avg_inhabitant_density_europe * surface
                            
                        elif polygon_oceania.contains(point):                            
                            nb_refugees += avg_inhabitant_density_oceania * surface
                            
        return nb_refugees
                        
                            
                            
                            
                            
                            
    # def draw_map(self, canvas, width, height):
    #     """
    #     Color the  map based on the sea level. 
    #     If the elevation is greater than the water level, then the colour is green.
    #     If the elevation is smaller than the water level, then the colour is blue.

    #     Parameters:
    #         ----------
    #         elevation_dico : dict
    #              Dictionary containing the elevation as key and the    associated coordinates (longitudes and latitudes) as values.
    #              year : int
    #              Considered year for observing the elevation

    #     Returns:
    #         -------
    #         None.
    #     """
    #     # Clear existing drawings
    #     canvas.delete("all")

    #     elevation = self.controller.get_sea_level(year)
    #     for elev, liste in self.elevation_dict.items():
            
    #         #Check if the points in the dictionary elevation_dict are below or above sea level
            
    #         if elev < elevation:  #If the elevation is below sea level
    #             for lat, long in liste:
    #                 x,y = width * lat, height * long  #Convert the lat, long into coordinates adapted to the canva
    #                 canvas.create_circle(x-1, y-1, x+1, y+1, fill="blue", width=2)  # Color each point at a given elevation below sea level in blue
                    
    #         else:     #If the elevation is above sea level
    #             for lat, long in liste: 
    #                 x,y = width * lat, height * long   #Convert the lat, long into coordinates adapted to the canva
    #                 canvas.create_circle(x-1, y-1, x+1, y+1, fill="green", width=2) # Color each point at a given elevation above sea level in green
                    
        

file_name = 'ETOPO_2022_v1_60s_N90W180_bed.nc'
file_france = 'fr_with_elevation.csv'
file_java = 'id.json'
file_bazil = 'geoBoundaries-BRA-ADM0_simplified.geojson'
dict_sea = ElevationData(file_name)
