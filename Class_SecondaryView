import netCDF4 as nc
import numpy as np
import tkinter as tk
from PIL import Image, ImageTk

from Class_Controller import Controller
from Class_Coordinate_Converter import CoordinateConverter

class SecondaryView:
    def __init__(self):
        self.controller = Controller()
        self.coordinateconverter = CoordinateConverter()

        self.netcdf_file = "ETOPO_2022_v1_60s_N90W180_bed.nc"

        # these will be set in generate_base_image()
        self.base_image = None
        self.photo      = None
        self.zoom = 1.0
        self.pan_x = 0
        self.pan_y = 0
        self.last_water_level = None


    def top_or_side(self):
        mode = self.controller.view_mode()
        return mode

    def generate_base_image(self, base_width, base_height, year, scenario):
        """Load once and build a PIL.Image of size (base_width x base_height)."""
        if self.base_image is not None and self.water_level == self.controller.get_sea_level(year, scenario):
            return

        self.water_level = self.controller.get_sea_level(year, scenario)

        with nc.Dataset(self.netcdf_file) as ds:
            lats  = ds.variables['lat'][:]
            lons  = ds.variables['lon'][:]
            elevs = ds.variables['z'][:]

        # map north→top by reversing latitude indices
        lat_idx = np.linspace(len(lats)-1, 0, base_height).round().astype(int)
        lon_idx = np.linspace(0, len(lons)-1, base_width).round().astype(int)
        elev_sub = elevs[lat_idx[:,None], lon_idx[None,:]]

        # build RGB array: blue if below water, green if above
        arr = np.empty((base_height, base_width, 3), dtype=np.uint8)
        below = elev_sub < self.water_level
        arr[...,0] = 0
        arr[...,1] = np.where(below, 0, 255)
        arr[...,2] = np.where(below, 255, 0)

        self.base_image = Image.fromarray(arr, mode='RGB')
        #print(f" Base image generated at {self.base_width}×{self.base_height}px")

    def redraw(self):
        """Scale & draw the base_image at (pan_x, pan_y)."""
        if self.base_image is None:
            return

        # current canvas size
        w = self.canvas.winfo_width()
        h = self.canvas.winfo_height()

        # scaled image size
        tw = max(1, int(w * self.zoom))
        th = max(1, int(h * self.zoom))

        # resize & convert to PhotoImage
        img = self.base_image.resize((tw, th), Image.NEAREST)
        self.photo = ImageTk.PhotoImage(img)

        # draw
        self.canvas.delete("all")
        self.canvas.create_image(int(self.pan_x), int(self.pan_y),
                                 anchor=tk.NW, image=self.photo)

    def on_resize(self, event):
        """
        Window was resized → re‑center the image (so it still fills the canvas).
        """
        w, h = event.width, event.height
        tw = int(w * self.zoom)
        th = int(h * self.zoom)

        # center it
        self.pan_x = (w - tw) / 2
        self.pan_y = (h - th) / 2
        self.redraw()

    def on_zoom(self, event):
        """
        Mouse wheel: zoom in/out by 10%, *around* the pointer position.
        Prevent zooming out smaller than canvas.
        """
        if self.base_image is None:
            return

        # Force canvas to update its size before measuring
        self.canvas.update_idletasks()
        canvas_w = self.canvas.winfo_width()
        canvas_h = self.canvas.winfo_height()
        img_w, img_h = self.base_image.size

        # Compute minimal zoom so image always covers canvas
        min_zoom_x = canvas_w / img_w
        min_zoom_y = canvas_h / img_h
        min_zoom = max(min_zoom_x, min_zoom_y, 0.01)  # tiny fallback safeguard

        # choose zoom factor
        factor = 1.1 if event.delta > 0 else 0.9
        old_zoom = self.zoom
        new_zoom = max(min_zoom, min(old_zoom * factor, 10.0))

        # pointer position in canvas coords
        mx, my = event.x, event.y

        # which image‑pixel is under the pointer?
        ix = (mx - self.pan_x) / old_zoom
        iy = (my - self.pan_y) / old_zoom

        # update zoom
        self.zoom = new_zoom

        # compute new pan so (ix,iy) still sits at (mx,my)
        self.pan_x = mx - ix * new_zoom
        self.pan_y = my - iy * new_zoom

        self.redraw()

    def create_map(self, frame, width, height, year, scenario):
        self.generate_base_image(width, height, year, scenario)

        self.canvas = frame  # just assign the passed canvas


        # bind resize & zoom
        self.canvas.bind("<Configure>", self.on_resize)
        self.canvas.bind("<MouseWheel>", self.on_zoom)

        # initial draw
        self.redraw()


